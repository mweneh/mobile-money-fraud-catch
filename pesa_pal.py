# -*- coding: utf-8 -*-
"""Pesa-Pal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XQC6nSNENh6KbGwbsYptqZKo_rf9TdFJ

##Problem Statement: Machine Learning for Fraudulent Transaction Classification in E-Commerce: A Case Study of the Pesapal Platform

####1. Introduction & Background

The exponential growth of e-commerce has been paralleled by a surge in sophisticated financial fraud, posing significant challenges to payment service providers like Pesapal. Fraudulent transactions lead to direct financial losses, erode customer trust, damage brand reputation, and incur substantial operational costs for fraud investigation and chargeback handling. While rule-based systems have been traditionally used for fraud detection, they often suffer from high false-positive rates, lack adaptability to evolving fraud patterns, and require constant manual updates.

Machine Learning (ML) offers a promising paradigm shift by enabling systems to learn complex, non-linear patterns from historical transaction data and adapt to new fraudulent tactics. The ability to accurately distinguish between legitimate and fraudulent transactions in real-time is critical for maintaining the integrity and security of digital payment ecosystems.

####2. Problem Definition

This research addresses the critical challenge of accurately classifying fraudulent transactions on Pesapal's e-commerce platform. The core problem is a binary classification task: given a set of transaction attributes (e.g., time, amount, merchant ID, customer location, device fingerprint), the objective is to assign a label of either "legitimate" or "fraudulent."

The primary complication is the highly imbalanced nature of the dataset, where fraudulent transactions represent a very small minority (often less than 1%) of all transactions. This class imbalance can bias standard classification algorithms towards predicting the majority class, leading to high overall accuracy but poor detection of the critical minority class (fraud). Therefore, the problem extends beyond simple classification to developing a robust model that effectively handles severe class imbalance.

####3. Research Gap & Justification

Although ML models for fraud detection have been widely studied, their performance is highly dependent on the specific context, data features, and fraud patterns unique to a platform. A model trained on data from one financial institution may not generalize well to another. There is a identified gap in the academic literature concerning the application and evaluation of advanced ML techniques specifically on transaction data from African fintech platforms like Pesapal, which may exhibit distinct transactional behaviors and fraud schemes compared to global counterparts.

####4. Research Objectives

The main objective of this study is to develop and evaluate a high-performance machine learning model for the accurate classification of fraudulent transactions on the Pesapal platform.

To achieve this, the following specific objectives are defined:

    To preprocess and engineer features from Pesapal's historical transaction dataset to make it suitable for machine learning modeling.

    To address the class imbalance problem.

    To train, validate, and compare the performance of multiple machine learning algorithms, including but not limited to: Logistic Regression, Decision Trees, Random Forests, Gradient Boosting Machines (e.g., XGBoost, LightGBM, CatBoost), and potentially neural networks.

    To optimize the hyperparameters of the most promising models to maximize detection performance.

    To evaluate the final model not just on overall accuracy, but on metrics appropriate for imbalanced datasets, such as Precision, Recall, F1-Score, Area Under the Precision-Recall Curve (AUPRC), and Area Under the Receiver Operating Characteristic Curve (AUC-ROC).

####5. Scope and Delimitations

This study will be confined to the historical transaction data provided by Pesapal. The research will focus on the classification task itself and will not extend to the real-time deployment and integration of the model into production systems. The feature set will be limited to the variables available within the provided dataset.

![image.png](data:image/png;base64,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)
"""

# Import all required libraries
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# For interactive plots (install with: pip install plotly)

import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.figure_factory as ff
PLOTLY_AVAILABLE = True
print(" Plotly available - Interactive plots enabled")


# Set style for better looking plots
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")

# Set display options
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)

#load data
train = pd.read_csv('/content/drive/MyDrive/PesaPal/training.csv')
test = pd.read_csv('/content/drive/MyDrive/PesaPal/test.csv')

# Check for missing values
print(" DATA QUALITY ASSESSMENT")
print("="*50)

print("Missing Values in Training Set:")
missing_train = train.isnull().sum()
print(missing_train[missing_train > 0])

print("\n Missing Values in Test Set:")
missing_test = test.isnull().sum()
print(missing_test[missing_test > 0])

# Data types overview
print(f"\n Data Types Overview:")
print(train.dtypes.value_counts())

# Unique values for categorical columns
categorical_cols = train.select_dtypes(include=['object']).columns.tolist()
print(f"\n Categorical Columns: {len(categorical_cols)}")
for col in categorical_cols:
    unique_count = train[col].nunique()
    print(f"  {col}: {unique_count} unique values")

# Numerical columns summary
numerical_cols = train.select_dtypes(include=[np.number]).columns.tolist()
print(f"\n Numerical Columns: {len(numerical_cols)}")
for col in numerical_cols:
    if col != 'FraudResult':
        print(f"  {col}: min={train[col].min():.2f}, max={train[col].max():.2f}")

# Fraud distribution analysis
print(" FRAUD DISTRIBUTION ANALYSIS")
print("="*50)

fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Simple count plot with inner circle
fraud_counts = train['FraudResult'].value_counts()

# Create the pie chart
axes[0].pie(
    fraud_counts.values,
    labels=['Legitimate', 'Fraud'],
    autopct='%1.1f%%',
    colors=['#2E86C1', '#E74C3C'],
    wedgeprops={'width': 0.4}  # Makes room for the inner circle
)

# Optional: Add a white circle in the middle (perfect for donut style)
centre_circle = plt.Circle((0, 0), 0.02, fc='white')
axes[0].add_artist(centre_circle)

axes[0].set_title('Overall Fraud Distribution')
axes[0].axis('equal')  # Keep it a circle

# Convert 'TransactionStartTime' to datetime
train['TransactionStartTime'] = pd.to_datetime(train['TransactionStartTime'])

# 2. Fraud rate by hour
train['Hour'] = train['TransactionStartTime'].dt.hour
hourly_fraud = train.groupby('Hour')['FraudResult'].agg(['sum', 'count'])
hourly_fraud['rate'] = hourly_fraud['sum'] / hourly_fraud['count']

axes[1].bar(hourly_fraud.index, hourly_fraud['rate'], color='orange', alpha=0.7)
axes[1].set_xlabel('Hour of Day')
axes[1].set_ylabel('Fraud Rate')
axes[1].set_title('Fraud Rate by Hour of Day')
axes[1].grid(True, alpha=0.3)

# 3. Daily fraud trend
daily_fraud = train.set_index('TransactionStartTime')['FraudResult'].resample('D').agg(['sum', 'count'])
daily_fraud['rate'] = daily_fraud['sum'] / daily_fraud['count']

axes[2].plot(daily_fraud.index, daily_fraud['rate'], color='red', linewidth=2)
axes[2].set_xlabel('Date')
axes[2].set_ylabel('Daily Fraud Rate')
axes[2].set_title('Daily Fraud Rate Trend')
axes[2].tick_params(axis='x', rotation=45)
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Print key statistics
print(f"\n Key Fraud Statistics:")
print(f"Peak fraud hour: {hourly_fraud['rate'].idxmax()}:00 ({hourly_fraud['rate'].max():.1%})")
print(f"Lowest fraud hour: {hourly_fraud['rate'].idxmin()}:00 ({hourly_fraud['rate'].min():.1%})")
print(f"Average daily fraud rate: {daily_fraud['rate'].mean():.1%}")
print(f"Highest daily fraud rate: {daily_fraud['rate'].max():.1%}")

# Analyze Amount and Value distributions
print(" AMOUNT & VALUE ANALYSIS")
print("="*50)

fig, axes = plt.subplots(2, 3, figsize=(18, 12))

# Amount analysis
legitimate_amounts = train[train['FraudResult'] == 0]['Amount']
fraud_amounts = train[train['FraudResult'] == 1]['Amount']

# 1. Amount distribution
axes[0,0].hist(legitimate_amounts, bins=50, alpha=0.7, label='Legitimate', density=True, color='blue')
axes[0,0].hist(fraud_amounts, bins=50, alpha=0.7, label='Fraud', density=True, color='red')
axes[0,0].set_xlabel('Amount')
axes[0,0].set_ylabel('Density')
axes[0,0].set_title('Amount Distribution by Fraud Status')
axes[0,0].legend()
axes[0,0].set_xlim(0, train['Amount'].quantile(0.95))  # Remove extreme outliers for visibility

# 2. Amount box plot
train_melted = pd.melt(train[['FraudResult', 'Amount']],
                      id_vars=['FraudResult'], value_vars=['Amount'])
sns.boxplot(data=train, x='FraudResult', y='Amount', ax=axes[0,1])
axes[0,1].set_title('Amount Distribution by Fraud Status')
axes[0,1].set_xlabel('Fraud Status (0=Legitimate, 1=Fraud)')

# 3. Log-transformed Amount
axes[0,2].hist(np.log1p(legitimate_amounts), bins=50, alpha=0.7, label='Legitimate', density=True)
axes[0,2].hist(np.log1p(fraud_amounts), bins=50, alpha=0.7, label='Fraud', density=True)
axes[0,2].set_xlabel('Log(Amount + 1)')
axes[0,2].set_ylabel('Density')
axes[0,2].set_title('Log-Transformed Amount Distribution')
axes[0,2].legend()

# Value analysis
legitimate_values = train[train['FraudResult'] == 0]['Value']
fraud_values = train[train['FraudResult'] == 1]['Value']

# 4. Value distribution
axes[1,0].hist(legitimate_values, bins=50, alpha=0.7, label='Legitimate', density=True, color='blue')
axes[1,0].hist(fraud_values, bins=50, alpha=0.7, label='Fraud', density=True, color='red')
axes[1,0].set_xlabel('Value')
axes[1,0].set_ylabel('Density')
axes[1,0].set_title('Value Distribution by Fraud Status')
axes[1,0].legend()
axes[1,0].set_xlim(0, train['Value'].quantile(0.95))

# 5. Amount vs Value scatter plot
sample_size = min(5000, len(train))  # Sample for performance
sample_data = train.sample(sample_size)
scatter = axes[1,1].scatter(sample_data['Amount'], sample_data['Value'],
                           c=sample_data['FraudResult'], cmap='RdYlBu_r', alpha=0.6)
axes[1,1].set_xlabel('Amount')
axes[1,1].set_ylabel('Value')
axes[1,1].set_title('Amount vs Value (Colored by Fraud)')
plt.colorbar(scatter, ax=axes[1,1])

# 6. Statistical comparison
# Perform statistical tests
from scipy.stats import ks_2samp, mannwhitneyu

ks_stat_amount, ks_p_amount = ks_2samp(legitimate_amounts, fraud_amounts)
mw_stat_amount, mw_p_amount = mannwhitneyu(legitimate_amounts, fraud_amounts)

ks_stat_value, ks_p_value = ks_2samp(legitimate_values, fraud_values)
mw_stat_value, mw_p_value = mannwhitneyu(legitimate_values, fraud_values)

# Create a summary table
test_results = pd.DataFrame({
    'Feature': ['Amount', 'Amount', 'Value', 'Value'],
    'Test': ['KS-Test', 'Mann-Whitney', 'KS-Test', 'Mann-Whitney'],
    'P-Value': [ks_p_amount, mw_p_amount, ks_p_value, mw_p_value],
    'Significant': [ks_p_amount < 0.05, mw_p_amount < 0.05, ks_p_value < 0.05, mw_p_value < 0.05]
})

axes[1,2].axis('tight')
axes[1,2].axis('off')
table = axes[1,2].table(cellText=test_results.values, colLabels=test_results.columns,
                        cellLoc='center', loc='center')
table.auto_set_font_size(False)
table.set_fontsize(9)
axes[1,2].set_title('Statistical Test Results')

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"\n Amount Statistics:")
print(f"Legitimate: Mean={legitimate_amounts.mean():.2f}, Median={legitimate_amounts.median():.2f}")
print(f"Fraud: Mean={fraud_amounts.mean():.2f}, Median={fraud_amounts.median():.2f}")

print(f"\n Value Statistics:")
print(f"Legitimate: Mean={legitimate_values.mean():.2f}, Median={legitimate_values.median():.2f}")
print(f"Fraud: Mean={fraud_values.mean():.2f}, Median={fraud_values.median():.2f}")

# Correlation analysis and feature importance
print(" CORRELATION & FEATURE IMPORTANCE ANALYSIS")
print("="*50)

fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. Correlation heatmap
numeric_cols = train.select_dtypes(include=[np.number]).columns
correlation_matrix = train[numeric_cols].corr()

# Create mask for upper triangle
mask = np.triu(np.ones_like(correlation_matrix, dtype=bool))
sns.heatmap(correlation_matrix, mask=mask, annot=True, cmap='RdYlBu_r',
            center=0, ax=axes[0,0], fmt='.2f', square=True)
axes[0,0].set_title('Feature Correlation Matrix')

# 2. Correlation with target variable
target_corr = correlation_matrix['FraudResult'].drop('FraudResult').sort_values(key=abs, ascending=False)
colors = ['red' if x > 0 else 'blue' for x in target_corr.values]
axes[0,1].barh(range(len(target_corr)), target_corr.values, color=colors, alpha=0.7)
axes[0,1].set_yticks(range(len(target_corr)))
axes[0,1].set_yticklabels(target_corr.index)
axes[0,1].set_xlabel('Correlation with FraudResult')
axes[0,1].set_title('Feature Correlation with Target')
axes[0,1].grid(True, alpha=0.3)

# 3. Feature importance using mutual information
try:
    from sklearn.feature_selection import mutual_info_classif

    # Prepare features (remove target and handle missing values)
    feature_cols = [col for col in numeric_cols if col != 'FraudResult']
    X_features = train[feature_cols].fillna(0)
    y_target = train['FraudResult']

    # Calculate mutual information scores
    mi_scores = mutual_info_classif(X_features, y_target, random_state=42)
    mi_scores_series = pd.Series(mi_scores, index=feature_cols).sort_values(ascending=True)

    # Plot mutual information scores
    mi_scores_series.plot(kind='barh', ax=axes[1,0], color='skyblue')
    axes[1,0].set_title('Feature Importance (Mutual Information)')
    axes[1,0].set_xlabel('Mutual Information Score')
    axes[1,0].grid(True, alpha=0.3)

    print(f" Mutual Information calculated for {len(feature_cols)} features")

except ImportError:
    axes[1,0].text(0.5, 0.5, 'Scikit-learn not available\nfor Mutual Information',
                   ha='center', va='center', transform=axes[1,0].transAxes)
    axes[1,0].set_title('Feature Importance (Mutual Information)')

# 4. Feature variance analysis
feature_variances = train[feature_cols].var().sort_values(ascending=True)
axes[1,1].barh(range(len(feature_variances)), feature_variances.values, color='lightgreen', alpha=0.7)
axes[1,1].set_yticks(range(len(feature_variances)))
axes[1,1].set_yticklabels(feature_variances.index)
axes[1,1].set_xlabel('Variance')
axes[1,1].set_title('Feature Variance Analysis')
axes[1,1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Print top correlations
print(f"\n Top Feature Correlations with Fraud:")
for feature, corr in target_corr.head(5).items():
    print(f"  {feature}: {corr:.3f}")

# Advanced time series analysis
print(" TIME SERIES DEEP DIVE ANALYSIS")
print("="*50)

# Prepare time-based features
train['Date'] = train['TransactionStartTime'].dt.date
train['Hour'] = train['TransactionStartTime'].dt.hour
train['DayOfWeek'] = train['TransactionStartTime'].dt.day_name()
train['Month'] = train['TransactionStartTime'].dt.month
train['DayOfMonth'] = train['TransactionStartTime'].dt.day

fig, axes = plt.subplots(3, 2, figsize=(16, 15))

# 1. Daily fraud count and rate
daily_stats = train.groupby('Date')['FraudResult'].agg(['sum', 'count', 'mean'])
ax1 = axes[0,0]
ax2 = ax1.twinx()

line1 = ax1.plot(daily_stats.index, daily_stats['sum'], color='red', linewidth=2, label='Fraud Count')
line2 = ax2.plot(daily_stats.index, daily_stats['mean'], color='orange', linewidth=2, label='Fraud Rate')

ax1.set_xlabel('Date')
ax1.set_ylabel('Fraud Count', color='red')
ax2.set_ylabel('Fraud Rate', color='orange')
ax1.set_title('Daily Fraud Count and Rate')
ax1.tick_params(axis='x', rotation=45)
ax1.grid(True, alpha=0.3)

# Combine legends
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left')

# 2. Weekly pattern
day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
weekly_stats = train.groupby('DayOfWeek')['FraudResult'].agg(['sum', 'count', 'mean'])
weekly_stats = weekly_stats.reindex(day_order)

axes[0,1].bar(weekly_stats.index, weekly_stats['mean'], color='lightblue', alpha=0.7)
axes[0,1].set_xlabel('Day of Week')
axes[0,1].set_ylabel('Fraud Rate')
axes[0,1].set_title('Weekly Fraud Pattern')
axes[0,1].tick_params(axis='x', rotation=45)
axes[0,1].grid(True, alpha=0.3)

# Add count labels
for i, (day, row) in enumerate(weekly_stats.iterrows()):
    axes[0,1].text(i, row['mean'] + 0.001, f"n={row['count']}",
                   ha='center', va='bottom', fontsize=9)

# 3. Monthly pattern
monthly_stats = train.groupby('Month')['FraudResult'].agg(['sum', 'count', 'mean'])
axes[1,0].plot(monthly_stats.index, monthly_stats['mean'], marker='o', linewidth=3, markersize=8, color='green')
axes[1,0].set_xlabel('Month')
axes[1,0].set_ylabel('Fraud Rate')
axes[1,0].set_title('Monthly Fraud Pattern')
axes[1,0].grid(True, alpha=0.3)
axes[1,0].set_xticks(range(1, 13))

# 4. Hourly heatmap by day of week
hourly_daily = train.groupby(['DayOfWeek', 'Hour'])['FraudResult'].mean().unstack(fill_value=0)
hourly_daily = hourly_daily.reindex(day_order)

im = axes[1,1].imshow(hourly_daily.values, cmap='Reds', aspect='auto')
axes[1,1].set_xticks(range(24))
axes[1,1].set_yticks(range(7))
axes[1,1].set_yticklabels(day_order)
axes[1,1].set_xlabel('Hour of Day')
axes[1,1].set_title('Fraud Rate Heatmap: Day vs Hour')
plt.colorbar(im, ax=axes[1,1])

# 5. Rolling statistics
daily_fraud_rate = daily_stats['mean']
rolling_7d = daily_fraud_rate.rolling(window=7, center=True).mean()
rolling_30d = daily_fraud_rate.rolling(window=30, center=True).mean()

axes[2,0].plot(daily_stats.index, daily_fraud_rate, alpha=0.3, color='gray', label='Daily')
axes[2,0].plot(daily_stats.index, rolling_7d, color='blue', linewidth=2, label='7-day MA')
axes[2,0].plot(daily_stats.index, rolling_30d, color='red', linewidth=2, label='30-day MA')
axes[2,0].set_xlabel('Date')
axes[2,0].set_ylabel('Fraud Rate')
axes[2,0].set_title('Fraud Rate with Moving Averages')
axes[2,0].legend()
axes[2,0].tick_params(axis='x', rotation=45)
axes[2,0].grid(True, alpha=0.3)

# 6. Transaction volume vs fraud rate correlation
axes[2,1].scatter(daily_stats['count'], daily_stats['mean'], alpha=0.6, color='purple')
axes[2,1].set_xlabel('Daily Transaction Volume')
axes[2,1].set_ylabel('Daily Fraud Rate')
axes[2,1].set_title('Transaction Volume vs Fraud Rate')
axes[2,1].grid(True, alpha=0.3)

# Add correlation coefficient
volume_fraud_corr = daily_stats['count'].corr(daily_stats['mean'])
axes[2,1].text(0.05, 0.95, f'Correlation: {volume_fraud_corr:.3f}',
               transform=axes[2,1].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

plt.tight_layout()
plt.show()

# Print time-based insights
print(f"\n Time-based Insights:")
print(f"Highest risk day: {weekly_stats['mean'].idxmax()} ({weekly_stats['mean'].max():.1%})")
print(f"Lowest risk day: {weekly_stats['mean'].idxmin()} ({weekly_stats['mean'].min():.1%})")
print(f"Highest risk month: {monthly_stats['mean'].idxmax()} ({monthly_stats['mean'].max():.1%})")
print(f"Peak fraud hour: {train.groupby('Hour')['FraudResult'].mean().idxmax()}:00")
print(f"Volume-Fraud correlation: {volume_fraud_corr:.3f}")

# Advanced feature engineering
print(" ADVANCED FEATURE ENGINEERING")
print("="*50)

# Create new features
print("Creating new features...")

# 1. Amount and Value interactions
train['Amount_Value_Ratio'] = train['Amount'] / (train['Value'] + 1e-6)  # Add small value to avoid division by zero
train['Amount_Value_Interaction'] = train['Amount'] * train['Value']
train['Amount_Value_Difference'] = train['Amount'] - train['Value']

# 2. Time-based features
train['IsWeekend'] = train['DayOfWeek'].isin(['Saturday', 'Sunday']).astype(int)
train['IsBusinessHour'] = ((train['Hour'] >= 9) & (train['Hour'] <= 17)).astype(int)
train['IsLateNight'] = ((train['Hour'] >= 22) | (train['Hour'] <= 6)).astype(int)

# 3. Statistical features (if we have multiple transactions per account)
if 'AccountId' in train.columns:
    account_stats = train.groupby('AccountId')['Amount'].agg(['count', 'mean', 'std', 'min', 'max'])
    account_stats.columns = ['Account_TxnCount', 'Account_AvgAmount', 'Account_StdAmount', 'Account_MinAmount', 'Account_MaxAmount']
    account_stats['Account_AmountRange'] = account_stats['Account_MaxAmount'] - account_stats['Account_MinAmount']

    # Merge back to main dataset
    train = train.merge(account_stats, left_on='AccountId', right_index=True, how='left')

# 4. Binning features
train['AmountBin'] = pd.qcut(train['Amount'], q=10, labels=False, duplicates='drop')
train['ValueBin'] = pd.qcut(train['Value'], q=10, labels=False, duplicates='drop')

# 5. Log transformations
train['LogAmount'] = np.log1p(train['Amount'])
train['LogValue'] = np.log1p(train['Value'])

print(" Feature engineering complete!")

# Analyze new features
new_features = ['Amount_Value_Ratio', 'Amount_Value_Interaction', 'Amount_Value_Difference',
                'IsWeekend', 'IsBusinessHour', 'IsLateNight', 'LogAmount', 'LogValue']

# Add account features if they exist
if 'Account_TxnCount' in train.columns:
    new_features.extend(['Account_TxnCount', 'Account_AvgAmount', 'Account_StdAmount'])

fig, axes = plt.subplots(2, 4, figsize=(20, 10))
axes = axes.flatten()

for idx, feature in enumerate(new_features[:8]):  # Plot first 8 features
    if feature in train.columns:
        # Check if feature is binary
        if train[feature].nunique() <= 2:
            # Bar plot for binary features
            fraud_rate = train.groupby(feature)['FraudResult'].mean()
            axes[idx].bar(fraud_rate.index, fraud_rate.values, color=['lightblue', 'coral'], alpha=0.7)
            axes[idx].set_xlabel(feature)
            axes[idx].set_ylabel('Fraud Rate')
        else:
            # Histogram for continuous features
            legitimate = train[train['FraudResult'] == 0][feature].dropna()
            fraud = train[train['FraudResult'] == 1][feature].dropna()

            if len(legitimate) > 0 and len(fraud) > 0:
                axes[idx].hist(legitimate, bins=30, alpha=0.7, label='Legitimate', density=True, color='blue')
                axes[idx].hist(fraud, bins=30, alpha=0.7, label='Fraud', density=True, color='red')
                axes[idx].legend()

        axes[idx].set_title(f'{feature} Distribution')
        axes[idx].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Calculate correlation of new features with target
print(f"\n New Feature Correlations with Fraud:")
for feature in new_features:
    if feature in train.columns:
        corr = train[feature].corr(train['FraudResult'])
        if not np.isnan(corr):
            print(f"  {feature}: {corr:.3f}")

# Feature summary
print(f"\nFeature Engineering Summary:")
print(f"Original features: {len(numeric_cols)}")
print(f"New features created: {len([f for f in new_features if f in train.columns])}")
print(f"Total features: {len(train.select_dtypes(include=[np.number]).columns)}")

new_train = train.to_csv('new_train.csv', index=False)

# Interactive dashboard with Plotly
if PLOTLY_AVAILABLE:
    print(" CREATING INTERACTIVE DASHBOARD")
    print("="*50)

    # Create interactive fraud overview dashboard
    fig = make_subplots(
        rows=2, cols=3,
        subplot_titles=('Fraud Distribution', 'Daily Fraud Trends', 'Hourly Pattern',
                       'Amount by Fraud Status', 'Feature Correlation', 'Risk Analysis'),
        specs=[[{"type": "pie"}, {"type": "xy"}, {"type": "xy"}],
               [{"type": "xy"}, {"type": "xy"}, {"type": "xy"}]]
    )

    # 1. Fraud distribution pie chart
    fraud_counts = train['FraudResult'].value_counts()
    fig.add_trace(go.Pie(
        labels=['Legitimate', 'Fraud'],
        values=[fraud_counts[0], fraud_counts[1]],
        hole=0.4,
        marker_colors=['#2E86C1', '#E74C3C'],
        textinfo='label+percent',
        name="Fraud Distribution",
        insidetextorientation='auto' # Corrected parameter
    ), row=1, col=1)

    # 2. Daily fraud trends
    daily_fraud = train.groupby('Date')['FraudResult'].agg(['sum', 'count', 'mean'])
    fig.add_trace(go.Scatter(
        x=daily_fraud.index,
        y=daily_fraud['mean'],
        mode='lines+markers',
        name='Daily Fraud Rate',
        line=dict(color='#E74C3C', width=2),
        hovertemplate='Date: %{x}<br>Fraud Rate: %{y:.1%}<extra></extra>'
    ), row=1, col=2)

    # 3. Hourly pattern
    hourly_fraud = train.groupby('Hour')['FraudResult'].agg(['sum', 'count', 'mean'])
    fig.add_trace(go.Bar(
        x=hourly_fraud.index,
        y=hourly_fraud['mean'],
        marker_color='#F39C12',
        name='Hourly Fraud Rate',
        hovertemplate='Hour: %{x}<br>Fraud Rate: %{y:.1%}<br>Count: %{customdata}<extra></extra>',
        customdata=hourly_fraud['count']
    ), row=1, col=3)

    # 4. Amount distribution by fraud status
    fig.add_trace(go.Box(
        y=train[train['FraudResult']==0]['Amount'],
        name='Legitimate',
        marker_color='#2E86C1',
        boxpoints='outliers'
    ), row=2, col=1)

    fig.add_trace(go.Box(
        y=train[train['FraudResult']==1]['Amount'],
        name='Fraud',
        marker_color='#E74C3C',
        boxpoints='outliers'
    ), row=2, col=1)

    # 5. Top feature correlations
    target_corr = train.select_dtypes(include=[np.number]).corr()['FraudResult'].drop('FraudResult')
    top_corr = target_corr.abs().nlargest(8)

    fig.add_trace(go.Bar(
        x=top_corr.values,
        y=top_corr.index,
        orientation='h',
        marker_color=['red' if x > 0 else 'blue' for x in target_corr[top_corr.index]],
        name='Feature Correlation'
    ), row=2, col=2)

    # 6. Risk analysis by amount bins
    amount_bins = pd.qcut(train['Amount'], q=5, labels=['Very Low', 'Low', 'Medium', 'High', 'Very High'])
    risk_by_bin = train.groupby(amount_bins)['FraudResult'].agg(['sum', 'count', 'mean'])

    fig.add_trace(go.Bar(
        x=risk_by_bin.index,
        y=risk_by_bin['mean'],
        marker_color='#8E44AD',
        name='Risk by Amount Tier',
        hovertemplate='Tier: %{x}<br>Fraud Rate: %{y:.1%}<br>Count: %{customdata}<extra></extra>',
        customdata=risk_by_bin['count']
    ), row=2, col=3)

    # Update layout
    fig.update_layout(
        title_text=" Interactive Fraud Detection Dashboard",
        title_x=0.5,
        height=800,
        showlegend=True,
        template='plotly_white'
    )

    # Show the interactive plot
    fig.show()

    print("Interactive dashboard created!")
    print(" Hover over elements for detailed information")
    print(" Click legend items to toggle visibility")

else:
    print(" Plotly not available - Skipping interactive dashboard")
    print("Install with: pip install plotly")

#  Supervised Fraud Detection Pipeline
print(" SUPERVISED FRAUD DETECTION PIPELINE")
print("="*60)

try:

    from sklearn.model_selection import train_test_split
    from sklearn.metrics import (
        classification_report,
        confusion_matrix,
        roc_auc_score,
        precision_recall_curve,
        auc,
        RocCurveDisplay,
        PrecisionRecallDisplay
    )
    from lightgbm import LGBMClassifier
    from xgboost import XGBClassifier

    # -----------------------------
    # 1. Prepare data
    # -----------------------------
    target = "FraudResult"
    # Select features from the processed 'train' DataFrame
    features = [col for col in train.columns if col != target and train[col].dtype in [np.number, 'int64', 'float64']] # Select numeric features

    X = train[features]
    y = train[target]

    # Train-test split the 'train' data for evaluation
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, stratify=y, random_state=42
    )
    # X_train = train.drop(columns=['FraudResult'])
    # y_train = train['FraudResult']

    # X_test = test.drop(columns=['FraudResult'])
    # y_test = test['FraudResult']

    # Handle potential NaNs after splitting (some engineered features might have NaNs)
    X_train = X_train.fillna(0)
    X_test = X_test.fillna(0)


    # -----------------------------
    # 2. Define models
    # -----------------------------
    models = {
        "LightGBM": LGBMClassifier(
            n_estimators=500,
            learning_rate=0.05,
            class_weight="balanced",  # handles imbalance
            random_state=42
        ),
        "XGBoost": XGBClassifier(
            n_estimators=500,
            learning_rate=0.05,
            scale_pos_weight=(len(y_train) - sum(y_train)) / sum(y_train),  # imbalance
            use_label_encoder=False,
            eval_metric="logloss",
            random_state=42
        )
    }

    results = {}

    # -----------------------------
    # 3. Train & Evaluate
    # -----------------------------
    for name, model in models.items():
        print(f"\n Training {name}...")
        model.fit(X_train, y_train)

        # Predictions
        y_pred = model.predict(X_test)
        y_proba = model.predict_proba(X_test)[:, 1]

        # Metrics
        roc_auc = roc_auc_score(y_test, y_proba)
        precision, recall, _ = precision_recall_curve(y_test, y_proba)
        pr_auc = auc(recall, precision)

        results[name] = {
            "roc_auc": roc_auc,
            "pr_auc": pr_auc,
            "report": classification_report(y_test, y_pred, zero_division=0, digits=3),
            "conf_matrix": confusion_matrix(y_test, y_pred)
        }

        # -----------------------------
        # 4. Plots
        # -----------------------------
        fig, axes = plt.subplots(1, 2, figsize=(12, 5))

        # ROC Curve
        RocCurveDisplay.from_estimator(model, X_test, y_test, ax=axes[0])
        axes[0].set_title(f"{name} - ROC Curve (AUC = {roc_auc:.3f})")

        # Precision-Recall Curve
        PrecisionRecallDisplay.from_estimator(model, X_test, y_test, ax=axes[1])
        axes[1].set_title(f"{name} - PR Curve (AUC = {pr_auc:.3f})")

        plt.show()

        # Print report
        print(f"\n {name} Results:")
        print(results[name]["report"])
        print("Confusion Matrix:\n", results[name]["conf_matrix"])

    # -----------------------------
    # 5. Compare results
    # -----------------------------
    print("\n MODEL COMPARISON")
    print("="*60)
    for name, res in results.items():
        print(f"{name}: ROC-AUC={res['roc_auc']:.3f}, PR-AUC={res['pr_auc']:.3f}")

except ImportError as e:
    print("Some libraries are missing. Install with:")
    print("!pip install lightgbm xgboost matplotlib scikit-learn")

# Create advanced risk scoring model
print(" ADVANCED RISK SCORING MODEL")
print("="*50)

# Create a composite risk score
def create_risk_score(df):
    """Create a composite risk score based on multiple factors"""
    risk_score = 0
    weight_sum = 0

    # Amount-based risk (normalized)
    if 'Amount' in df.columns:
        amount_percentile = df['Amount'].rank(pct=True)
        risk_score += amount_percentile * 0.3
        weight_sum += 0.3

    # Value-based risk (normalized)
    if 'Value' in df.columns:
        value_percentile = df['Value'].rank(pct=True)
        risk_score += value_percentile * 0.3
        weight_sum += 0.3

    # Time-based risk
    if 'IsLateNight' in df.columns:
        risk_score += df['IsLateNight'] * 0.1
        weight_sum += 0.1

    # Weekend risk
    if 'IsWeekend' in df.columns:
        risk_score += df['IsWeekend'] * 0.1
        weight_sum += 0.1

    # Ratio-based risk
    if 'Amount_Value_Ratio' in df.columns:
        ratio_percentile = df['Amount_Value_Ratio'].rank(pct=True)
        risk_score += ratio_percentile * 0.2
        weight_sum += 0.2

    # Normalize by total weights
    if weight_sum > 0:
        risk_score = risk_score / weight_sum

    return risk_score

# Calculate risk scores
print("Calculating composite risk scores...")
train['RiskScore'] = create_risk_score(train)

# Create risk tiers
train['RiskTier'] = pd.qcut(train['RiskScore'], q=5,
                           labels=['Very Low', 'Low', 'Medium', 'High', 'Very High'])

# Analysis of risk scores
fig, axes = plt.subplots(2, 3, figsize=(18, 12))

# 1. Risk score distribution
axes[0,0].hist(train[train['FraudResult']==0]['RiskScore'], bins=50, alpha=0.7,
               label='Legitimate', density=True, color='blue')
axes[0,0].hist(train[train['FraudResult']==1]['RiskScore'], bins=50, alpha=0.7,
               label='Fraud', density=True, color='red')
axes[0,0].set_xlabel('Risk Score')
axes[0,0].set_ylabel('Density')
axes[0,0].set_title('Risk Score Distribution')
axes[0,0].legend()
axes[0,0].grid(True, alpha=0.3)

# 2. Risk tier analysis
tier_analysis = train.groupby('RiskTier')['FraudResult'].agg(['sum', 'count', 'mean'])
axes[0,1].bar(tier_analysis.index, tier_analysis['mean'], color='coral', alpha=0.7)
axes[0,1].set_xlabel('Risk Tier')
axes[0,1].set_ylabel('Fraud Rate')
axes[0,1].set_title('Fraud Rate by Risk Tier')
axes[0,1].tick_params(axis='x', rotation=45)
axes[0,1].grid(True, alpha=0.3)

# Add count labels
for i, (tier, row) in enumerate(tier_analysis.iterrows()):
    axes[0,1].text(i, row['mean'] + 0.01, f"n={row['count']}",
                   ha='center', va='bottom', fontsize=9)

# 3. ROC-like curve for risk score
from scipy import stats
risk_thresholds = np.linspace(0, 1, 100)
tpr_list, fpr_list = [], []

for threshold in risk_thresholds:
    predicted_fraud = (train['RiskScore'] >= threshold).astype(int)

    tp = len(train[(predicted_fraud == 1) & (train['FraudResult'] == 1)])
    fp = len(train[(predicted_fraud == 1) & (train['FraudResult'] == 0)])
    tn = len(train[(predicted_fraud == 0) & (train['FraudResult'] == 0)])
    fn = len(train[(predicted_fraud == 0) & (train['FraudResult'] == 1)])

    tpr = tp / (tp + fn) if (tp + fn) > 0 else 0
    fpr = fp / (fp + tn) if (fp + tn) > 0 else 0

    tpr_list.append(tpr)
    fpr_list.append(fpr)

axes[0,2].plot(fpr_list, tpr_list, linewidth=2, color='blue')
axes[0,2].plot([0, 1], [0, 1], 'k--', alpha=0.5)
axes[0,2].set_xlabel('False Positive Rate')
axes[0,2].set_ylabel('True Positive Rate')
axes[0,2].set_title('ROC Curve for Risk Score')
axes[0,2].grid(True, alpha=0.3)

# Calculate AUC
from sklearn.metrics import auc
roc_auc = auc(fpr_list, tpr_list)
axes[0,2].text(0.6, 0.2, f'AUC = {roc_auc:.3f}', fontsize=12,
               bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

# 4. Risk score vs actual fraud scatter
axes[1,0].scatter(train['RiskScore'], train['FraudResult'], alpha=0.1, s=10)
axes[1,0].set_xlabel('Risk Score')
axes[1,0].set_ylabel('Actual Fraud (0/1)')
axes[1,0].set_title('Risk Score vs Actual Fraud')
axes[1,0].grid(True, alpha=0.3)

# Add trend line
z = np.polyfit(train['RiskScore'], train['FraudResult'], 1)
p = np.poly1d(z)
axes[1,0].plot(train['RiskScore'].sort_values(), p(train['RiskScore'].sort_values()),
               "r--", alpha=0.8, linewidth=2)

# 5. Risk score by different segments
if 'Hour' in train.columns:
    hourly_risk = train.groupby('Hour')['RiskScore'].mean()
    axes[1,1].plot(hourly_risk.index, hourly_risk.values, marker='o', linewidth=2, color='green')
    axes[1,1].set_xlabel('Hour of Day')
    axes[1,1].set_ylabel('Average Risk Score')
    axes[1,1].set_title('Average Risk Score by Hour')
    axes[1,1].grid(True, alpha=0.3)

# 6. Precision-Recall curve
precision_list, recall_list = [], []

for threshold in risk_thresholds:
    predicted_fraud = (train['RiskScore'] >= threshold).astype(int)

    tp = len(train[(predicted_fraud == 1) & (train['FraudResult'] == 1)])
    fp = len(train[(predicted_fraud == 1) & (train['FraudResult'] == 0)])
    fn = len(train[(predicted_fraud == 0) & (train['FraudResult'] == 1)])

    precision = tp / (tp + fp) if (tp + fp) > 0 else 0
    recall = tp / (tp + fn) if (tp + fn) > 0 else 0

    precision_list.append(precision)
    recall_list.append(recall)

axes[1,2].plot(recall_list, precision_list, linewidth=2, color='purple')
axes[1,2].set_xlabel('Recall')
axes[1,2].set_ylabel('Precision')
axes[1,2].set_title('Precision-Recall Curve')
axes[1,2].grid(True, alpha=0.3)

# Calculate Average Precision
avg_precision = auc(recall_list, precision_list)
axes[1,2].text(0.1, 0.1, f'Avg Precision = {avg_precision:.3f}', fontsize=12,
               bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

plt.tight_layout()
plt.show()

# Print risk scoring results
print(f"\n Risk Scoring Results:")
print(f"Risk Score AUC: {roc_auc:.3f}")
print(f"Average Precision: {avg_precision:.3f}")

print(f"\n Risk Tier Performance:")
for tier, row in tier_analysis.iterrows():
    print(f"  {tier}: {row['mean']:.1%} fraud rate (n={row['count']})")

# Find optimal threshold
optimal_idx = np.argmax(np.array(tpr_list) - np.array(fpr_list))
optimal_threshold = risk_thresholds[optimal_idx]
print(f"\n Optimal Risk Threshold: {optimal_threshold:.3f}")
print(f"   TPR: {tpr_list[optimal_idx]:.3f}, FPR: {fpr_list[optimal_idx]:.3f}")

# Correlation with actual fraud
risk_fraud_corr = train['RiskScore'].corr(train['FraudResult'])
print(f"\n Risk Score - Fraud Correlation: {risk_fraud_corr:.3f}")

# Add SVM to the supervised fraud detection pipeline
print("\n Adding Linear SVM to the pipeline")
print("="*60)

try:
    from sklearn.svm import LinearSVC
    from sklearn.preprocessing import StandardScaler
    from sklearn.pipeline import make_pipeline

    # Scale the data before applying SVM
    scaler = StandardScaler()

    # Define the Linear SVM model
    # Use class_weight='balanced' to handle imbalance
    svm_model = make_pipeline(scaler, LinearSVC(class_weight='balanced', random_state=42, dual=False, max_iter=10000))

    # Add SVM to the existing models dictionary
    models["LinearSVM"] = svm_model

    # Train & Evaluate the new model
    name = "LinearSVM"
    model = models[name]

    print(f"\n Training {name}...")
    model.fit(X_train, y_train)

    # Predictions
    # LinearSVC does not have predict_proba, use decision_function
    y_pred = model.predict(X_test)
    y_scores = model.decision_function(X_test) # Use decision_function for metrics

    # Metrics
    roc_auc = roc_auc_score(y_test, y_scores)
    precision, recall, _ = precision_recall_curve(y_test, y_scores, pos_label=model.classes_[1])
    pr_auc = auc(recall, precision)

    results[name] = {
        "roc_auc": roc_auc,
        "pr_auc": pr_auc,
        "report": classification_report(y_test, y_pred, zero_division=0, digits=3),
        "conf_matrix": confusion_matrix(y_test, y_pred)
    }

    # Plots
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    # ROC Curve
    RocCurveDisplay.from_estimator(model, X_test, y_test, ax=axes[0])
    axes[0].set_title(f"{name} - ROC Curve (AUC = {roc_auc:.3f})")

    # Precision-Recall Curve
    PrecisionRecallDisplay.from_estimator(model, X_test, y_test, ax=axes[1])
    axes[1].set_title(f"{name} - PR Curve (AUC = {pr_auc:.3f})")

    plt.show()

    # Print report
    print(f"\n {name} Results:")
    print(results[name]["report"])
    print("Confusion Matrix:\n", results[name]["conf_matrix"])

    # Update model comparison printout
    print("\n UPDATED MODEL COMPARISON")
    print("="*60)
    for name, res in results.items():
        print(f"{name}: ROC-AUC={res['roc_auc']:.3f}, PR-AUC={res['pr_auc']:.3f}")


except ImportError:
    print("Scikit-learn is required for SVM. Install with:")
    print("!pip install scikit-learn")
except Exception as e:
    print(f"An error occurred: {e}")

# Prepare data for model training and export key results
print(" DATA EXPORT AND MODEL PREPARATION")
print("="*50)

# Create a clean dataset for modeling
modeling_features = []

# Add original numerical features
base_features = ['Amount', 'Value']
for feature in base_features:
    if feature in train.columns:
        modeling_features.append(feature)

# Add engineered features
engineered_features = ['LogAmount', 'LogValue', 'Amount_Value_Ratio',
                      'Amount_Value_Interaction', 'IsWeekend', 'IsBusinessHour',
                      'IsLateNight']
for feature in engineered_features:
    if feature in train.columns:
        modeling_features.append(feature)

# Add categorical features as numeric
categorical_features = ['CountryCode', 'ProviderId', 'ProductId', 'ChannelId', 'PricingStrategy']
for feature in categorical_features:
    if feature in train.columns and train[feature].dtype in ['int64', 'float64']:
        modeling_features.append(feature)

# Add risk score
if 'RiskScore' in train.columns:
    modeling_features.append('RiskScore')

print(f" Features selected for modeling: {len(modeling_features)}")
for i, feature in enumerate(modeling_features, 1):
    print(f"  {i:2d}. {feature}")

# Create modeling dataset
modeling_data = train[modeling_features + ['FraudResult']].copy()

# Handle missing values
print(f"\n Data cleaning:")
missing_before = modeling_data.isnull().sum().sum()
modeling_data = modeling_data.fillna(0)  # Simple imputation
missing_after = modeling_data.isnull().sum().sum()
print(f"  Missing values: {missing_before}  {missing_after}")

# Remove infinite values
inf_before = np.isinf(modeling_data.select_dtypes(include=[np.number])).sum().sum()
modeling_data = modeling_data.replace([np.inf, -np.inf], 0)
inf_before_after = np.isinf(modeling_data.select_dtypes(include=[np.number])).sum().sum()
print(f"  Infinite values: {inf_before}  {inf_before_after}")

# Feature statistics for modeling
print(f"\n Modeling dataset statistics:")
print(f"  Shape: {modeling_data.shape}")
print(f"  Memory usage: {modeling_data.memory_usage(deep=True).sum() / 1024**2:.2f} MB")
print(f"  Fraud rate: {modeling_data['FraudResult'].mean():.1%}")

# Export correlation matrix
feature_correlations = modeling_data.corr()['FraudResult'].drop('FraudResult').sort_values(key=abs, ascending=False)
print(f"\n Top 5 feature correlations with fraud:")
for feature, corr in feature_correlations.head().items():
    print(f"  {feature}: {corr:.3f}")

# Create feature importance ranking
feature_importance_df = pd.DataFrame({
    'Feature': feature_correlations.index,
    'Correlation': feature_correlations.values,
    'AbsCorrelation': feature_correlations.abs().values
}).sort_values('AbsCorrelation', ascending=False)

print(f"\n Feature importance ranking created")

# Prepare data splits information
print(f"\n Data split recommendations:")
print(f"  Total samples: {len(modeling_data):,}")
print(f"  Suggested train size: {int(len(modeling_data) * 0.7):,} (70%)")
print(f"  Suggested validation size: {int(len(modeling_data) * 0.15):,} (15%)")
print(f"  Suggested test size: {int(len(modeling_data) * 0.15):,} (15%)")

# Save key datasets (in practice, you'd save to files)
print(f"\n Key datasets prepared:")
print("   modeling_data - Clean dataset for ML models")
print("   feature_importance_df - Feature ranking by correlation")
print("   analysis_summary - Key metrics dictionary")

# Sample code for saving (uncomment to use)
# modeling_data.to_csv('fraud_modeling_data.csv', index=False)
# feature_importance_df.to_csv('feature_importance.csv', index=False)
# pd.DataFrame([analysis_summary]).to_csv('analysis_summary.csv', index=False)

print(f"\n Data preparation complete!")
print(f" Ready for machine learning model training")

# Display final modeling dataset info
print(f"\n Final modeling dataset preview:")
display(modeling_data.head())
print(f"\nDataset info:")
print(modeling_data.info())